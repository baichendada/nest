:sunny:<font size = 5> HELLO,大家好，我是**白晨**:heart:呀！</font>:cupid:今天又到了我们一起来学习的时间啦:cupid:，**苦心人、天不负，卧薪尝胆，三千越甲可吞吴**，一起加油吧:muscle::muscle:。
![在这里插入图片描述](https://img-blog.csdnimg.cn/00d531f852c146d0ba0409f5e3553744.gif)

---
# 前言
---
在[顺序表](https://blog.csdn.net/baichendada/article/details/122139815?spm=1001.2014.3001.5501)和[链表](https://blog.csdn.net/baichendada/article/details/122151737?spm=1001.2014.3001.5501)中我们讲述了数据结构最基本的两种结构，今天我们就要在这两种数据结构的基础上来继续认识另外两种数据结构——**栈**和**队列**。
为了内容的完整性以及可读性(主要是有进阶内容)，我将前一篇文章[栈结构全解析](https://blog.csdn.net/baichendada/article/details/122238378?spm=1001.2014.3001.5501)也搬到了这里。
废话不多说，正文见下

---

# 1.栈
----
##  1.1 栈的定义及结构
---
> **栈**：一种特殊的线性表，其==只允许在固定的一端进行插入和删除元素操作==。进行数据插入和删除操作的一端称为**栈顶**，另一端称为**栈底**。栈中的数据元素遵守后进先出LIFO(Last In First Out)的原则。
>
> 简单来说，<font color=Red>**栈是一种只能从一端进行插入和删除的遵循后进先出的线性表**</font>。
> 	![在这里插入图片描述](https://img-blog.csdnimg.cn/febfb1db746d4ac5838975f5fb19cdb2.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_19,color_FFFFFF,t_70,g_se,x_16)

> **压栈**：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/641d723c5251422aabd93fdf8db402f9.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

>**出栈**：栈的删除操作叫做出栈。出数据也在栈顶。
>![在这里插入图片描述](https://img-blog.csdnimg.cn/6b65e48d3a964833b86d0d170c21dde8.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/049591a79df94e68bc7bd2f116b2b234.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_20,color_FFFFFF,t_70,g_se,x_16)


如果你曾经了解过[函数栈帧](https://blog.csdn.net/baichendada/article/details/120929639?spm=1001.2014.3001.5501)，那么你应该对这种结构不陌生。但是还是要提醒一下，**函数栈帧中的栈是一种存储空间，而本篇文章中的栈是一种数据结构**，两者在结构上有相似之处。

---
我们现在已经了解了栈的结构了，那么栈到底怎么实现呢？
前文说到，栈是一种线性表，所以我们可以在顺序表和链表的基础上实现链表。
>我们来对比一下，顺序表和链表实现栈的优劣情况
>![在这里插入图片描述](https://img-blog.csdnimg.cn/da062ee528b4452cb5c894cfa8d04ef4.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

我们先来实现顺序栈

## 1.2 顺序栈
---
![在这里插入图片描述](https://img-blog.csdnimg.cn/8d03d00c723f4cf883d214c70925ff94.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

### 顺序栈结构
---

首先，我们先来写出栈的顺序表结构

> ```c
> typedef int STDataType;
> typedef struct Stack
> {
> STDataType* a;
> int top;//栈中数据个数
> int capacity;//栈总容量
> }ST;
> ```
> 首先，我们为了方便储存各种不同类型的数据，我们定义一个*SLDataType*，如果以后想改变储存数据的类型，直接修改 *SLDataType* 的定义即可。
>
> 接着，我们发现 Stack 中有一个指针，这个指针是用来指向动态内存开辟的空间的，也就是指向数据的。
>
> 最后，*top* 指的是顺序表中元素的个数，*capacity* 是指顺序表中最多能容纳元素的个数。
---

接下来，我们完成栈中非常重要的一步——实现接口函数
所有接口函数如下：

> ```c
> // 栈初始化
> void StackInit(ST* ps);
> // 栈销毁
> void StackDestroy(ST* ps);
> // 插入数据（入栈）
> void StackPush(ST* ps, STDataType x);
> // 删除数据 （出栈）
> void StackPop(ST* ps); 
> // 取栈顶数据 
> STDataType StackTop(ST* ps);
> // 栈中数据个数 
> int StackSize(ST* ps);
> // 判断栈是否为空 
> bool StackEmpty(ST* ps);
> ```

### 初始化和销毁
---

- 初始化其实非常好理解，就传一个顺序表的指针，我们将其中的数据先置空。

- 销毁就是，先将*size*和*capacity*置为0，再释放掉储存数据的空间。
>
>```c
>void StackInit(ST* ps)
>{
>	  assert(ps);
>	  ps->a = NULL;
>	  ps->capacity = 0;
>	  ps->top = 0;
>}
>void StackDestroy(ST* ps)
>{
>	  assert(ps);
>	  free(ps->a);
>	  ps->a = NULL;
>	  ps->capacity = 0;
>	  ps->top = 0;
>}
>```
---
### 判断栈是否为空、获取栈中数据个数 及 获取栈顶元素
---

 - 由于经常需要判断栈中是否为空以及获取栈的大小，所以我们单独将其功能封装成一个函数
 -  实现相对简单，判断为空只需要判断*top*是否为0，如果为0，返回真，非0，返回假
 - 获取栈的大小只需要将*top*值传出
 - 要获取栈顶元素就先得判断栈是否为空，然后将栈顶元素传出

 

> ```c  
> bool StackEmpty(ST* ps) 
> { 	
> assert(ps); 	
> return ps->top == 0; 
> }
> int StackSize(ST* ps)
> { 	
>  assert(ps);
>  return ps->top;
> } 
> STDataType StackTop(ST* ps)
> { 	
>  assert(ps); 	
>  assert(!StackEmpty(ps));
> 	return ps->a[ps->top - 1]; 
> }
> 
> ```

---
### 入栈 以及 出栈
---
由于栈只能从尾部（栈顶）插入/删除元素，所以只用实现尾插/尾删功能（尾插与尾删详细见[顺序表](https://blog.csdn.net/baichendada/article/details/122139815?spm=1001.2014.3001.5501)）。

入栈：
![在这里插入图片描述](https://img-blog.csdnimg.cn/bacb11c7a640438ea351f10c3136d20c.gif)

出栈：
![在这里插入图片描述](https://img-blog.csdnimg.cn/52aaabb935f64200921540667180a06c.gif)

```c
void StackPush(ST* ps, STDataType x)
{
	assert(ps);

	if (ps->top == ps->capacity)
	{
		int newCapacity = ps->capacity == 0 ? 4 : 2 * ps->capacity;
		STDataType* tmp = (STDataType*)realloc(ps->a, newCapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			printf("realloc fail");
			exit(-1);
		}
		ps->a = tmp;
		ps->capacity = newCapacity;
	}

	ps->a[ps->top] = x;
	ps->top++;
}
void StackPop(ST* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	ps->top--;
}
```
---

### 顺序栈全局代码
---


```c
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;

void StackInit(ST* ps)
{
	assert(ps);
	ps->a = NULL;
	ps->capacity = 0;
	ps->top = 0;
}

void StackDestroy(ST* ps)
{
	assert(ps);
	free(ps->a);
	ps->a = NULL;
	ps->capacity = 0;
	ps->top = 0;
}

void StackPush(ST* ps, STDataType x)
{
	assert(ps);

	if (ps->top == ps->capacity)
	{
		int newCapacity = ps->capacity == 0 ? 4 : 2 * ps->capacity;
		STDataType* tmp = (STDataType*)realloc(ps->a, newCapacity * sizeof(STDataType));
		if (tmp == NULL)
		{
			printf("realloc fail");
			exit(-1);
		}
		ps->a = tmp;
		ps->capacity = newCapacity;
	}

	ps->a[ps->top] = x;
	ps->top++;
}

void StackPop(ST* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	ps->top--;
}

STDataType StackTop(ST* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	return ps->a[ps->top - 1];
}

int StackSize(ST* ps)
{
	assert(ps);

	return ps->top;
}

bool StackEmpty(ST* ps)
{
	assert(ps);
	return ps->top == 0;
}
```
---
---
## 1.3 链栈
---
上文提到，链栈结构选择头作为栈顶实现入栈（头插）、出栈（头删）比较简单，所以这个结构大家可以动手写一写，与链表实现极为相似，这里不过多赘述。
![在这里插入图片描述](https://img-blog.csdnimg.cn/59169fa0020d46bf8a895be2f5972180.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_18,color_FFFFFF,t_70,g_se,x_16)
这次，我们要实现==用链尾当栈顶的非双向链表写法==。由于这种写法实际用途不大，所以我们只讲解基本实现思路。

### 链栈结构
---
1. 创建栈结构
 ```c
 typedef int STDataType;

typedef struct StackNode
{
	struct StackNode* next;
	STDataType data;
}STNode;

typedef struct Stack
{
	STNode* top;
	STNode* bottom;
}Stack;
 ```
这里由于单向链表的节点只能指向下一个节点，所以我们只能在栈结构中记录一下栈顶和栈底的位置。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f6bb2acf39f840768473a838d19da9f8.png#pic_center?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55m95pmoc2FtYQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

---
### 链栈入栈
---
2. 再来说下一个难题——如何入栈？ 

>  - 先创建一个新节点，将所给数据存入
>  - 判断*bottom*是否为NULL
>    + 如果是，说明栈中没有数据，则让*top*与*bottom*都指向新节点
>    + 如果不是，则实施尾插，尾插结束后，使*top*指向尾节点

```c
void StackPush(Stack* ps, STDataType data)
{
	assert(ps);

	STNode* newnode = (STNode*)malloc(sizeof(STNode));
	if (newnode == NULL)
	{
		printf("malloc fail\n");
		exit(-1);
	}
	newnode->data = data;
	newnode->next = NULL;

	if (ps->bottom == NULL)
	{
		ps->bottom = ps->top = newnode;
	}
	else
	{
		ps->top->next = newnode;
		ps->top = newnode;
	}
	
}
```
---
### 链栈出栈
---
3. 如何出栈？

> + 首先，判断是否栈中为空
>  + 其次，遍历找到尾节点的前一个节点，删除数据，*top*指向原尾节点前一个元素
>   + 这里有个特殊情况，如果栈中只有一个元素，那么删除完后，还得把*bottom*还原为NULL

```c
void StackPop(Stack* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	STNode* Del = ps->bottom;

	if (ps->bottom == ps->top)
	{
		free(ps->bottom);
		ps->bottom = ps->top = NULL;
		return;
	}

	while (Del->next != ps->top)
	{
		Del = Del->next;
	}

	free(ps->top);
	Del->next = NULL;
	ps->top = Del;
}
```
剩下的函数都不难实现，大家可以参考下文代码实现。

### 全局代码
---


```c
typedef int STDataType;

typedef struct StackNode
{
	struct StackNode* next;
	STDataType data;
}STNode;

typedef struct Stack
{
	STNode* top;
	STNode* bottom;
}Stack;

// 初始化栈 
void StackInit(Stack* ps);
// 入栈 
void StackPush(Stack* ps, STDataType data);
// 出栈 
void StackPop(Stack* ps);
// 获取栈顶元素 
STDataType StackTop(Stack* ps);
// 获取栈底元素
STDataType StackBottom(Stack* ps);
// 获取栈中有效元素个数 
int StackSize(Stack* ps);
// 检测栈是否为空，如果为空返回非零结果，如果不为空返回0 
bool StackEmpty(Stack* ps);
// 销毁栈 
void StackDestroy(Stack* ps);
 
void StackInit(Stack* ps)
{
	assert(ps);
	ps->top = NULL;
	ps->bottom = NULL;
}

void StackDestroy(Stack* ps)
{
	assert(ps);

	STNode* cur = ps->bottom;

	while (cur)
	{
		STNode* next = cur->next;
		free(cur);
		cur = next;
	}

	ps->bottom = ps->top = NULL;
}

bool StackEmpty(Stack* ps)
{
	assert(ps);

	return ps->bottom == NULL;
}

void StackPush(Stack* ps, STDataType data)
{
	assert(ps);

	STNode* newnode = (STNode*)malloc(sizeof(STNode));
	if (newnode == NULL)
	{
		printf("malloc fail\n");
		exit(-1);
	}
	newnode->data = data;
	newnode->next = NULL;

	if (ps->bottom == NULL)
	{
		ps->bottom = ps->top = newnode;
	}
	else
	{
		ps->top->next = newnode;
		ps->top = newnode;
	}
	
}

void StackPop(Stack* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	STNode* Del = ps->bottom;

	if (ps->bottom == ps->top)
	{
		free(ps->bottom);
		ps->bottom = ps->top = NULL;
		return;
	}

	while (Del->next != ps->top)
	{
		Del = Del->next;
	}

	free(ps->top);
	Del->next = NULL;
	ps->top = Del;
}

STDataType StackTop(Stack* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	return ps->top->data;
}

STDataType StackBottom(Stack* ps)
{
	assert(ps);
	assert(!StackEmpty(ps));

	return ps->bottom->data;
}

int StackSize(Stack* ps)
{
	assert(ps);

	int sz = 0;
	STNode* cur = ps->bottom;

	while (cur)
	{
		sz++;
		cur = cur->next;
	}

	return sz;
}
```
---
---

# 2.队列
---
## 2.1 队列的定义和结构
---

> **队列**：只允许在**一端**进行**插入**数据操作，在**另一端**进行**删除**数据操作的特殊**线性表**，队列具有先进先出 ==FIFO(First In First Out)== 的性质。
> **入队列**：进行插入操作的一端称为队尾 
> **出队列**：进行删除操作的一端称为队头
> ![image-20220102184555129](C:\Users\李若尘\AppData\Roaming\Typora\typora-user-images\image-20220102184555129.png)
>
> 这个结构，我们可以想到什么呢？
> 没错，就像是一列火车。我们可以做个假设，把**每个节点**视为一个**火车车厢**，那么一个**队列结构**就好像是一列**直行的火车**。那么入队就可以视为火车进站时，车厢依次入站，前面的车厢先进，后面的车厢后进；出队就可以理解为，火车出站时，前面的车厢先离开，后面的车厢后离开。
> 先来感受一下先进先出的特点：
> 入队(进站)：
>
> ![队列特点1](C:\Users\李若尘\Desktop\素材\栈与队列\队列特点1.gif)
>
> 出队 (出队)：
>
> ![队列特点2](C:\Users\李若尘\Desktop\素材\栈与队列\队列特点2.gif)





